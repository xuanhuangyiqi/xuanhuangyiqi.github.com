<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Htedsv Backyard]]></title>
  <link href="http://xuanhuangyiqi.github.io/atom.xml" rel="self"/>
  <link href="http://xuanhuangyiqi.github.io/"/>
  <updated>2014-01-14T16:59:33+01:00</updated>
  <id>http://xuanhuangyiqi.github.io/</id>
  <author>
    <name><![CDATA[htedsv]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[翻译：如何读论文]]></title>
    <link href="http://xuanhuangyiqi.github.io/blog/2013/09/28/"/>
    <updated>2013-09-28T00:00:00+02:00</updated>
    <id>http://xuanhuangyiqi.github.io/blog/2013/09/</id>
    <content type="html"><![CDATA[<p><a href="http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf">原文地址</a></p>

<p>本文只翻译了论文第二三部分</p>

<h1>读论文的三个阶段</h1>

<h2>第一个阶段</h2>

<p>第一个阶段就是快速浏览文章，对文章有概括的认识。你可以决定是否进行下面的阶段，这个阶段大约需要5-10分钟，并且包含一下几个步骤：</p>

<ol>
<li>仔细阅读标题、摘要和介绍</li>
<li>阅读段落和子段落标题，但是忽略其他的一切。</li>
<li>粗看数学的内容（如果有的话）来确定基本的数学基础</li>
<li>读结论</li>
<li>粗看索引，剔出一些你已经看过的。</li>
</ol>


<p>在第一阶段结束的时候，你应该能够回答5个问题：</p>

<ol>
<li>类别：这个论文属于什么类？测量论文？一个已有系统的分析？还是一个研究标准的描述？</li>
<li>上下文：和哪些其他论文相关？有哪些理论基础被用于分析这个问题？</li>
<li>正确性：这个假设正确吗？</li>
<li>贡献：这个论文的主要贡献</li>
<li>清晰：这个论文值得写吗？</li>
</ol>


<p>通过这些信息，你可能选择不继续读（并且不用打印出来，节省树木）。这可能因为你对这篇论文没兴趣，或者你对相关的领域了解的不充分，或者这些作者设定了错误的假设。第一个阶段对于不是你领域的论文已经足够了，但是某天会被证明很重要。</p>

<p>顺便的，当你写一篇论文时，你可以期望大多数审阅人可以只进行第一个阶段。小心选择清晰的段落和子段落标题，并且写简明综合的概述，如果一个审阅人在一个阶段之后不能理解主旨，这个论文就可能被拒绝；如果一个读者不能在5分钟内不能理解论文的关键点，这个文章就可能不再被读。因为这些理由，一个能通过选好的图总结一篇论文的“绘声绘色的概述”是一个接触的想法，并且可以越来越多的在科学周刊中看到。</p>

<h2>第二个阶段</h2>

<p>在第二个阶段，越多要有更多的关注，但是忽略证明的细节。这可以帮助你记住关键点，或者按照你读到的在旁边记下注释。 Augsburg大学的Dominik Grusemann表示，你“记下不懂得部分或者想问作者的问题”。如果你是一个论文评审人，这些注释会帮助你当你在写回顾的时候，和在一个项目会议中回忆你写的的回顾的时候。</p>

<ol>
<li>仔细看论文中图、图表和其他图解。特别关注图形。它的坐标轴有标注吗？结果展示有错误条吗，他们有很重要的统计学意义。这些常见的错误会把匆忙、错误的从真正优秀的论文中分辨出来。</li>
<li>记得为了以后的阅读，标记重要的未读会议。</li>
</ol>


<p>第二个部分对于有经验的读者应该占据一个小时。度过这个阶段，你应该有能力抓住文章的内容。你应该有能力根据支持的证据给别人总结论文的主要事实。这个详细的级别对于一篇你感兴趣的论文是合适的，但是在你的研究特长上面还不够。</p>

<p>有时候你即使在第二阶段结束的时候也不能理解一篇文章。这可能是因为这个主题的术语或者所写对你是新的。或者作者想用你不理解的证明方法或者实验技巧，所以这个论文的含量是不能预测的。这个论文可能是有没有证实的断言和大量的会议挤出来的。或者有可能多的时候太晚了，你很累了。你现在可以选择（a）把这个论文放一边，希望你的生涯中不需要明白这些材料（b）读完背景材料之后，等会再回到这篇论文中（c）保留现在的状态，进入第三阶段。</p>

<h2>第三个阶段</h2>

<p>为了完整理解这篇论文，尤其你是一个审稿人，需要第三个阶段。第三阶段最关键的是尝试“实际重现”这篇论文：就是说，和作者做相同的假设，重新做一边下面的工作。通过对比这个重新构造的过程和论文，你就可以不仅仅看出论文体现的创造力，而且还有没有写出来的失败和假设。</p>

<p>这个过程需要把大量精力放在细节。你可以了解并且挑战陈述中的每个假设。另外，你可以考虑你如何表述一个特定的想法。这个和虚拟与实际情况的对比能引导你对证明过程和展示技巧更加敏锐的目光，而且你非常可能把它加到你的工具指令中。在这个过程中，你可以略记下一些想法为了未来的工作。
这个过程对于初学者可能持续很多小时，对于有经验的读者也要多于一个小时，甚至更多。在这个阶段的最后，你应该有能力从记忆中把把想法重新构造出论文全部的结构，而且有能力识别重要和不重要的观点，尤其是，你应该有能力指出重要工作的隐含的假设，和缺失的引用，以及试验和分析技巧潜在问题。</p>

<h1>做文献调研</h1>

<p>论文阅读技巧在文献调研的过程中得到测试。这将需要你读10篇论文，可能在一个不熟悉的领域。你需要读什么样的论文？这里有你应该怎么用三阶段法实施。
首先，使用学术搜索引擎，比如Google Scholar或者CiteSeer，还有选择好的关键词去搜索3-5篇这个领域中最近高引用的论文。每篇文章进行一个阶段，然后读他们的相关工作的段落。你会发现一个近几年相关工作的简略总结。如果你能发现这样一个调研，你就完成了。读这个调研，祝你好运。</p>

<p>否则，在第二步，在参考书目中发现共同的引用和重复的作者姓名。这些是这个领域的关键论文和研究员。下载这些关键论文并且把它们放一边。然后去这些关键研究员的网站去看看他们最近在哪里发表。这会帮你识别这个领域的顶级会议，因为最好的研究员经常在顶级会议上发表。</p>

<p>第三步就是去这些顶级会议的网站，看看最近的进程。一个快速的浏览将帮助你经常了解最近高质量的相关工作。这些论文，还有你刚才放一边的东西，组成了你调研的第一个版本，完成这些论文的第二个阶段，如果他们都引用了一篇你之前没发现的论文，把它添加进来并且读完它，增量是必须的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Crash Logs 基本调研]]></title>
    <link href="http://xuanhuangyiqi.github.io/blog/2013/09/02/ios-crack/"/>
    <updated>2013-09-02T13:30:03+02:00</updated>
    <id>http://xuanhuangyiqi.github.io/blog/2013/09/02/ios-crack</id>
    <content type="html"><![CDATA[<p>1个月的实习马上就要结束，本文主要介绍我在实习期间主要调研内容——iOS app崩溃时的Crash Log分析与总结。</p>

<h1>Crash Log 是什么？</h1>

<p>首先需要介绍下Crash Log的基本信息，在大家在使用iOS app时有时候会因为各种原因而自动退出，比如系统内存不足，比如程序本身的bug，比如越狱造成的系统不稳定。总之，凡是app的自动退出都会对应的生成一个log文件，记录系统崩溃时的系统信息和崩溃栈。如下是一个crash log的样子: <a href="http://xuanhuangyiqi.github.io/assets/Bildschirmfoto2013-09-02um2.25.41PM.png">Crash Log example</a>。</p>

<p>从图中可一看到，每一次崩溃发生时，会有一个Crash Log存储在iOS设备中，并且在连接Xcode时转移到mac上。</p>

<p>另外，看到下面各个Thread的函数堆栈中，能看到每行最右面有错误发生的<em>函数名</em>和对应的<em>行数</em>，如果你自己尝试做这个试验就会发现开始<em>函数</em>的位置是一个16位内存地址，过了一会才会自动被Xcode转换成函数名。</p>

<h1>Symbolicate</h1>

<p>Symbolicate过程就是把对应的函数栈转化成函数名的过程，我们为了方便，在后面把这个过程叫做<em>解析</em>。这个过程是怎么实现的呢？</p>

<p>首先，无论是在模拟器，还是真机debug一个app的过程中，除了XXX.app之外，还会生成一个XXX.app.dSYM文件（准确地说，这两个都是文件夹），如果你想知道生成的这两个文件路径，可以在terminal下使用mac的内嵌find工具mdfind：</p>

<div>
  <pre><code class='bash'>$ mdfind -name &quot;XXX.app&quot;</code></pre>
</div>


<p>它是Spotlight功能的核心，在你的系统有文件更新时能及时更新索引，因此速度还是很快的，当然它还可以根据其他所引进行搜索。</p>

<p>dSYM文件保存了这个app的符号表，即指令内存地址和源代码的函数名和行数关系。这个文件显然保存了app源码的大量信息，因此是不能随意公布的。当然，只有你本机上包含有app的dSYM文件，其中的指令地址才能被解析成函数名（这句话是不严谨的，我们后面在解释）。</p>

<h1>Xcode 解析工具</h1>

<p>解析的工作分为很多步，我们来介绍几个Xcode自带的相关小工具：</p>

<ul>
<li>atos，用以获取某内存地址所对应的函数名。用法：</li>
</ul>


<div>
  <pre><code class='bash'>$ atos -o /path/to/XXX.app/XXX.app.dSYM/Contents/Resources/DWARF/XXX -arch i386 0x973000</code></pre>
</div>


<p>这个函数是指定了arch的，即i386，这是模拟器（或者说mac）的处理器arch，对于iOS设备就是armv6／7。如果你指定的arch和app以及dsym文件的arch不对，是会报错的。那么如何知道一个app的arch呢？前面我已经说了最常见的两个，如果你不确定是哪个，就可以用</p>

<ul>
<li>dwarfdump</li>
</ul>


<div>
  <pre><code class='bash'>$ dwarfdump -u ~/Library/Developer/Xcode/iOS\ DeviceSupport/5.0.1\ \(9A405\)/Symbols/System/Library/Frameworks/UIKit.framework/UIKit</code></pre>
</div>


<ul>
<li>symbolicatecrash 这是symbolicate过程的核心脚本</li>
</ul>


<div>
  <pre><code class='bash'>$ /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKit.framework/Versions/A/Resources/symbolicatecrash</code></pre>
</div>


<h1>动态库与静态库</h1>

<p>在学习C语言的时候，我们就应该接触过这两种库，静态库是在编译时把其中涉及到的指令一起放入最终生成的app，动态库则是在运行时动态查找库的。在iOS开发中，动态库的常见形式是dylib或者Framework。</p>

<p>无论是app还是Framework，在生成的时候都是有特定的arch的，这是可以用dwarfdump命令可以查到。但是app会把符号表放到单独的dSYM文件中，库文件的符号表会在自己内部。这就是我现在不能理解的问题，只要有足够多种类的语句，是可以通过外部app的调用把库的每条语句解析出来的。这是不是一种不安全的设计？</p>

<h1>现有Crash Log服务</h1>

<ul>
<li>QuincyApp 主要用于app发行前的crash管理</li>
<li>Crashlytics 界面友好</li>
<li>Crittercism 统计内容详细</li>
</ul>


<h1>解析过程</h1>

<p>在执行解析的过程中，首先从dSYM文件中找到app编译时所调用的动态库的名称、UUID、arch。然后利用mac自带的mdfind功能在全局搜索是否存在对应的库，只有完全匹配才可以解析。目前遇到的问题是如果使用模拟器制造crash，那么crash文件底层库的内容不会被解析出来，已经判断出是因为Xcode.app文件下的arch为i386的Framework的UUID与app的dSYM的不符。具体原因需要进一步了解。而真机测试时调用的库文件在另外的文件夹，似乎不会出现类似的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个简单的同义词聚类方法]]></title>
    <link href="http://xuanhuangyiqi.github.io/blog/2013/04/19/yi-ge-jian-dan-de-tong-yi-ci-ju-lei-fang-fa/"/>
    <updated>2013-04-19T15:57:00+02:00</updated>
    <id>http://xuanhuangyiqi.github.io/blog/2013/04/19/yi-ge-jian-dan-de-tong-yi-ci-ju-lei-fang-fa</id>
    <content type="html"><![CDATA[<p>今天忽然想起上次水了一把冯如杯的事。</p>

<p>当时的东西简单说是要做一个从文本提取关键词的东西。攒了一些文本之后用TF-IDF计算了下每个词的重要性。但是发现一个问题：很多文章的重要词汇都是同义词，比如“北京” “首都”之类的。</p>

<p>当时还不会LDA啥的高级方法，也不知道怎么生成词的特征向量，所以此方法推荐给以下情况：</p>

<ul>
<li>不想浪费时间搞复杂算法</li>
<li>对准确性要求一般</li>
<li>样本规模比较小</li>
</ul>


<p>首先我们基于一个事实：一句话会在几个实体之间建立联系，比如</p>

<blockquote><p>苹果是一种水果。</p>

<p>小学生每天要去学校上学。</p></blockquote>

<p>这种关系不一定是具体的关系，也有可能是脑中抽象的关系，比如</p>

<blockquote><p>我今天下午在咖啡厅用笔记本上网</p></blockquote>

<p>咖啡厅和笔记本之间其实没有表面联系，但是却在我们脑中有一个比较强的抽象关联，想到咖啡厅，我们容易想到自己在咖啡厅用笔记本上网。即使是否定某种关联的句子也肯定是我们容易想到一起的某些东西，比如：</p>

<blockquote><p>地球不是绕着太阳转的。</p>

<p>天狗吃月是骗小孩子的。</p></blockquote>

<p>基于这个事实，我把这些文本分隔成句子，对每个句子中出现的所有名词看成一个个节点，任意两个词之间边权 + 1（初始都是0），之后根据情况定一个阈值，高于阈值的边保留，低的删掉。最后根据每个名词的TF &ndash; IDF值从高到低排序，对于某个词x，如果与比它TF &ndash; IDF大的词y在一个子图上，那么忽略x，也就是说每个子图最多只输出TF &ndash; IDF最大的一个词。</p>

<p>虽然这个理论很站不住脚，不过记得当时效果很好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python下的lambda递归包装]]></title>
    <link href="http://xuanhuangyiqi.github.io/blog/2013/04/11/pythonxia-de-lambdadi-gui-bao-zhuang/"/>
    <updated>2013-04-11T11:33:50+02:00</updated>
    <id>http://xuanhuangyiqi.github.io/blog/2013/04/11/pythonxia-de-lambdadi-gui-bao-zhuang</id>
    <content type="html"><![CDATA[<p>一直觉得python是一个c语系向lisp语系的妥协（比如行内for/if），这也把python的语法搞得复杂了许多，不过函数式思想渗透的依然不够彻底，主要表现在lambda函数不能进行递归调用（当然lisp也是不支持直接调用的），这样限制python下的lambda成为了一个鸡肋的语法糖，我在<a href="http://htedsv.com:8880/?id=3">笔记</a>的意义中也提到了。其实解决起来倒也简单——加一个包装，比如我定义为函数<code>g(func, args)</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>g = lambda func, *args:  func(func, *args)</span></code></pre></td></tr></table></div></figure>


<p>然后就可以写自递归函数了，例如经典的求阶乘</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>f = lambda self, n: 1 if n == 1 else n*self(self, n-1)
</span><span class='line'>g(f, 10)</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[任务+md笔记——一次GTD实践]]></title>
    <link href="http://xuanhuangyiqi.github.io/blog/2013/04/05/ren-wu-plus-mdbi-ji-ci-gtdshi-jian/"/>
    <updated>2013-04-05T18:32:17+02:00</updated>
    <id>http://xuanhuangyiqi.github.io/blog/2013/04/05/ren-wu-plus-mdbi-ji-ci-gtdshi-jian</id>
    <content type="html"><![CDATA[<p>一直没找到特别顺心的GTD工具，大多都是因为不能很好的和其他app配合，另外比较奇怪为什么没有比较完善的开源GTD app,于是自己写一个，重在把任务+笔记结合，并且可以通过Geek Tool和Alfred更新和查看简单任务信息，用vi作笔记，配合起来非常方便。项目中有明确的实施细节和用法。</p>

<p><a title="项目" href="https://github.com/xuanhuangyiqi/open-task" target="_blank">项目</a>  <a href="http://task.htedsv.com" target="_blank">效果</a></p>

<p>ps: 想到一个问题，那就是这个东西和blog有什么区别，似乎都可以用题目和内容来解释他的功能，但是对于笔记，内容更多是没有被读者内化的东西，而blog应该是知识外化的过程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[生命游戏与细胞自动机]]></title>
    <link href="http://xuanhuangyiqi.github.io/blog/2013/03/10/sheng-ming-you-xi-yu-xi-bao-zi-dong-ji/"/>
    <updated>2013-03-10T15:25:03+01:00</updated>
    <id>http://xuanhuangyiqi.github.io/blog/2013/03/10/sheng-ming-you-xi-yu-xi-bao-zi-dong-ji</id>
    <content type="html"><![CDATA[<p>&ldquo;Cellular Automaton&#8221;，ein Interessante Modell, was ist benutzt in viele Felder. Ich kann diesem Konzept nicht deutlich erklaeren, Weil ich nur die Prozess verstehe, keinen weitere Benutzungen. Um mehr Informationen zu erkuendigt werden, suchen Sie es nach Wikipedia.</p>

<p>Aber ich finde ein Phaenomen interessant. &ldquo;Cellular Automaton&rdquo; war erhoben durch ein Spiel, &ldquo;Conways Spiel des Leben&rdquo;. Die Regel ist sehr einfach verstanden. Und darunter ist die code</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import time
</span><span class='line'>from random import random
</span><span class='line'>
</span><span class='line'>SIZE = 20
</span><span class='line'>
</span><span class='line'>matrix = [[int(random()*2) for y in range(SIZE)] for x in range(SIZE)]
</span><span class='line'>
</span><span class='line'>while True:
</span><span class='line'>    for x in matrix:
</span><span class='line'>        for y in x:
</span><span class='line'>            if y: print 1,
</span><span class='line'>            else: print ' ',
</span><span class='line'>        print
</span><span class='line'>    print '\n\n\n\n';
</span><span class='line'>    time.sleep(1)
</span><span class='line'>    matrix = (lambda t:
</span><span class='line'>                [
</span><span class='line'>                    [
</span><span class='line'>                        [0,0,t[x][y],1,1][sum([t[p+x][q+y] for p, q in [(0,1),(1,0),(-1,0),(0,-1)] if (p+x in range(SIZE) and q+y in range(SIZE))])]
</span><span class='line'>                        for y in range(SIZE)
</span><span class='line'>                    ] for x in range(SIZE)
</span><span class='line'>                ]
</span><span class='line'>            )(matrix)</span></code></pre></td></tr></table></div></figure>


<p>我发现这个过程竟然是收敛的，问题来了，如何制定收敛的规则呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推送来电消息到桌面]]></title>
    <link href="http://xuanhuangyiqi.github.io/blog/2013/01/26/tui-song-lai-dian-xiao-xi-dao-zhuo-mian/"/>
    <updated>2013-01-26T02:08:12+01:00</updated>
    <id>http://xuanhuangyiqi.github.io/blog/2013/01/26/tui-song-lai-dian-xiao-xi-dao-zhuo-mian</id>
    <content type="html"><![CDATA[<blockquote><p>Condition 1:IT男有时候会把手机放在一个非常隐蔽的地方，然后专心致志的盯着屏幕写代码，这时来了重要电话，你却没听见。</p>

<p>Condition 2:出门匆忙，手机忘了带，又不方便回去拿，如何及时知道有谁正在给你打电话?</p></blockquote>

<p><img src="http://xuanhuangyiqi.github.io/images/original_ZIeB_7c5500000bcc118d.jpg"></p>

<p>于是写了以下脚本来实现推送来电信息到桌面的脚本。</p>

<h2>前提 环境</h2>

<ul>
<li>mac: python(twisted), growl</li>
<li>vps: python(twisted)</li>
<li>android: on{X}</li>
</ul>


<h2>思路</h2>

<p>为了能适应更多情况，我们假设手机及电脑可能不在同一个局域网内，那么显然他们之间没有一个简单的通信方式。所以要依靠VPS，当然如果你有独立的PHP空间，并且用PHP来实现也是一样的。</p>

<p>手机：考虑到只有手机向VPS的请求，而没有反向，所以使用UDP或者http请求比较方便。单独为这个脚本写一个Android程序成本有点高，于是使用了微软的<a href="http://onx.ms/" target="_blank">on{X}</a>服务，简单地说，它是一个Android上的ifttt，用户可以自己用脚本实现“trigger-&gt;service”的功能。简单了解之后，发现on{X}的网络服务只有http请求。</p>

<p>电脑：IP及端口经常变化，而且考虑到服务器的性能，不宜轮询，遂与服务器保持TCP连接，这样服务器同时也能接受http请求（http请求在网络层就是TCP请求）。</p>

<h2>实现</h2>

<p>使用了python的twisted框架，以下是代码：</p>

<pre class="brush: python; gutter: true">#Client

import os
import time
import urllib
from twisted.internet import reactor
from twisted.internet.protocol import Factory, Protocol
from twisted.internet.endpoints import TCP4ClientEndpoint

class Greeter(Protocol):
    def sendMessage(self, msg):
        self.transport.write(&quot;%s\n&quot; % msg)
        pass

    def dataReceived(self, msg):
        msg = urllib.unquote(msg)
        os.system(&quot;export G_TITLE=%s;growl %s&quot;% (&quot;From\ Your\ Phone&quot;, msg))

class GreeterFactory(Factory):
    def buildProtocol(self, addr):
        return Greeter()

def gotProtocol(p):
    pass

point = TCP4ClientEndpoint(reactor, &quot;&lt;SERVER&gt;&quot;, &lt;PORT&gt;)
d = point.connect(GreeterFactory())
d.addCallback(gotProtocol)
reactor.run()</pre>


<pre class="brush: python; gutter: true">#Server

from twisted.internet.protocol import Protocol, Factory
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.internet import reactor

class Echo(Protocol):
    def sendMessage(self, msg):
        self.transport.write(&quot;%s&quot; % msg)

    def dataReceived(self, data):
        #self.transport.write(data)
        if data.startswith(&#039;GET&#039;):
            msg = data.split(&#039;\n&#039;)[0].split(&#039; &#039;)[1]
            msg = msg[6:]
            for x in self.factory.protocols:
                if x != self:
                    x.sendMessage(msg)
    def connectionLost(self, reason):
        print &#039;lost&#039;
        self.factory.protocols.remove(self)

class EFactory(Factory):
    protocol = Echo
    def __init__(self, quote=None):
        self.quote = quote or &#039;An&#039;
        self.protocols = []
    def buildProtocol(self, addr):
        p = self.protocol()
        p.factory = self
        self.protocols.append(p)
        return p

while True:
    endpoint = TCP4ServerEndpoint(reactor, &lt;PORT&gt;)
    endpoint.listen(EFactory(&quot;Ok&quot;))
    reactor.run()
    print &#039;stop&#039;</pre>


<pre class="brush: javascript; gutter: true">//Android
device.telephony.on(&#039;incomingCall&#039;, function (signal) 
{
    var notification = device.notifications.createNotification(&#039;Calling&#039;);
    notification.show();
    device.ajax(
    {
      url: &#039;http://&lt;SERVER&gt;:&lt;PORT&gt;/?msg=Call%20From:&#039;+signal.phoneNumber,
      type: &#039;GET&#039;,
      headers: {
        &#039;Content-Type&#039;: &#039;application/xml&#039;
      }
    },
    function onSuccess(body, textStatus, response) {
      var parsedBody;
      if(!(body &amp;&amp; (parsedBody = JSON.parse(body)))) {
        var error = {};
        error.message = &#039;invalid body format&#039;;
        error.content = body;
          console.error(&#039;error: &#039;,error);
      }
      console.info(&#039;successfully received http response!&#039;);
      notification.content = &#039;successfully received http response!&#039;;
      notification.show();
    },
    function onError(textStatus, response) {
      var error = {};
      error.message = textStatus;
      error.statusCode = response.status;
        console.error(&#039;error: &#039;,error);
    });
});</pre>


<h2>难点</h2>


<p>值得一提的是小米的权限管理比较恶心，开始我的来电事件一直没有被捕捉到，就是因为被小米拦截了，并且没有给出任何提示。直到现在短信监听器依然不能用，应该是这部分API被锁在MIUI里面了。所以只是实现了来电提示，而没有短信提示。</p>

<p>on{X}的不提供urlencode功能，所以不能用来推送短信内容或者来电人姓名。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim使用者的Evernote使用经验（仅供mac用户参考）]]></title>
    <link href="http://xuanhuangyiqi.github.io/blog/2013/01/23/vimshi-yong-zhe-de-evernoteshi-yong-jing-yan-jin-gong-macyong-hu-can-kao-/"/>
    <updated>2013-01-23T20:17:40+01:00</updated>
    <id>http://xuanhuangyiqi.github.io/blog/2013/01/23/vimshi-yong-zhe-de-evernoteshi-yong-jing-yan-jin-gong-macyong-hu-can-kao-</id>
    <content type="html"><![CDATA[<p>平时在vim下写东西比较多，很多操作vim操作都习惯了，但是缺点就是不易管理和同步，vimwiki等插件也都用过，但是很难做到evernote这么强大（尽管evernote有很多缺点，后面详述）。evernote在编辑习惯上和大多数IDE一致，而且不能像vim定制快捷键，再加上各种延迟，编辑过程很不爽，于是尝试在vim下编辑，然后同步到evernote的方案。</p>

<h1>vimrc + evernote_applescript_api</h1>

<p>在<code>~/.vimrc</code>中设置快捷键</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>map &lt;F6&gt; :call SaveToEN()&lt;CR&gt;
</span><span class='line'>func SaveToEN()
</span><span class='line'>      exec "osascript /path/to/savetoen.scpt "
</span><span class='line'>endfunc</span></code></pre></td></tr></table></div></figure>


<p>之后编写对应的<code>.scpt</code>脚本即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>create note title filepath with text content notebook "回顾总结"</span></code></pre></td></tr></table></div></figure>


<p>但是问题出在Applescript的文件操作不支持中文，出现乱码，尝试各种文件操作用法均无果，没有找到合适解决方案，目测可能原因有两个：</p>

<ol>
<li>苹果开发者压根没打算会有非英语语言者使用Applescript，读写文件使用ASCII。</li>
<li>读写文件使用的是Mac自己的编码，而不是UTF8。（可能性不大）</li>
</ol>


<p>无论如何，没有必要继续尝试。</p>

<h1>vimrc+pbcopy</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func SaveToEn()
</span><span class='line'>    exec "w"
</span><span class='line'>    exec "!cat % &gt; pbcopy"
</span><span class='line'>endfunc</span></code></pre></td></tr></table></div></figure>


<p>pbcopy是mac下的复制命令，执行这个操作之后，文件内容就进入剪切版了，在 Evernote中粘贴就好了。什么？你写markdown？看下面的方法吧</p>

<h1>vimrc + vimwiki = Markdown</h1>

<p>很多人离开Evernote是因为它不支持markdown，那么看看下面这个方法：</p>

<p>vimwiki是一个vim的插件，可以写markdown语法，然后导出成HTML文件，详细内容自行查看</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:help vimwiki</span></code></pre></td></tr></table></div></figure>


<p>我们的目标就是每次在vi中按下F6时打开生成的html，之后就可以轻松复制粘贴了。但是首先要能够区分什么样的文件打开html文件，什么样的直接放进剪切板，我们这里把所有.wiki的文件认为是需要用html打开的。那么下一步就是要让vim知道什么后缀的文件是wiki文件。首先要确定vim不认识这个文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:echo &filetype</span></code></pre></td></tr></table></div></figure>


<p>如果没有输出，说明确实不认识，否则的话记住这个输出，并且跳过下面这个步骤。</p>

<p>如果vim不认识这个文件，就需要修改<code>filetype.vim</code>，没有的话创建</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>:echo $VIMRUNTINE
</span><span class='line'>/usr/share/vim/vim73
</span><span class='line'>sudo vi /usr/share/vim/vim73/filetype.vim</span></code></pre></td></tr></table></div></figure>


<p>添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>au BufNewFile,BufRead *.wiki    setf vimwiki</span></code></pre></td></tr></table></div></figure>


<p>vimwiki的html导出路径管理不是很方便，例如要在<code>/&lt;path&gt;/vimwiki/</code>下面写wiki文件，那么html回保存在<code>/&lt;path&gt;/vimwiki_html/</code>，不是很方便，我的做法是修改<code>~/.vim/ftplugin/vimwiki.vim</code>文件第201行为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\ w &lt;bar&gt; call vimwiki#html#Wiki2HTML(expand(VimwikiGet('&lt;strong&gt;path&lt;/strong&gt;')),</span></code></pre></td></tr></table></div></figure>


<p>这样就会在wiki的同文件夹下生成html。</p>

<p>然后再修改下vimrc</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func SaveToEn()
</span><span class='line'>    exec "w"; 
</span><span class='line'>    if &filetype == vimwiki'
</span><span class='line'>        exec &quot;Vimwiki2HTML&quot;
</span><span class='line'>        exec &quot;!open %:r.html&quot;
</span><span class='line'>    else
</span><span class='line'>        exec &quot;!cat % &gt; pbcopy&quot;
</span><span class='line'>    endif
</span><span class='line'>endfunc</span></code></pre></td></tr></table></div></figure>


<p>大功告成了！</p>
]]></content>
  </entry>
  
</feed>
