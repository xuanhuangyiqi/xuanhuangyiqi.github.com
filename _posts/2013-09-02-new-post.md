---
layout: post
title: "iOS Crash Logs 基本调研"
description: ""
category: 
tags: [iOS, crash, survey]
---
{% include JB/setup %}

1个月的实习马上就要结束，本文主要介绍我在实习期间主要调研内容——iOS app崩溃时的Crash Log分析与总结。

# Crash Log 是什么？

首先需要介绍下Crash Log的基本信息，在大家在使用iOS app时有时候会因为各种原因而自动退出，比如系统内存不足，比如程序本身的bug，比如越狱造成的系统不稳定。总之，凡是app的自动退出都会对应的生成一个log文件，记录系统崩溃时的系统信息和崩溃栈。如下是一个crash log的样子: [Crash Log example]({{ site.url }}/assets/Bildschirmfoto2013-09-02um2.25.41PM.png)。

从图中可一看到，每一次崩溃发生时，会有一个Crash Log存储在iOS设备中，并且在连接Xcode时转移到mac上。

另外，看到下面各个Thread的函数堆栈中，能看到每行最右面有错误发生的*函数名*和对应的*行数*，如果你自己尝试做这个试验就会发现开始*函数*的位置是一个16位内存地址，过了一会才会自动被Xcode转换成函数名。

# Symbolicate

Symbolicate过程就是把对应的函数栈转化成函数名的过程，我们为了方便，在后面把这个过程叫做*解析*。这个过程是怎么实现的呢？

首先，无论是在模拟器，还是真机debug一个app的过程中，除了XXX.app之外，还会生成一个XXX.app.dSYM文件（准确地说，这两个都是文件夹），如果你想知道生成的这两个文件路径，可以在terminal下使用mac的内嵌find工具mdfind：
{% highlight bash %}
$ mdfind -name "XXX.app"
{% endhighlight %}
它是Spotlight功能的核心，在你的系统有文件更新时能及时更新索引，因此速度还是很快的，当然它还可以根据其他所引进行搜索。

dSYM文件保存了这个app的符号表，即指令内存地址和源代码的函数名和行数关系。这个文件显然保存了app源码的大量信息，因此是不能随意公布的。当然，只有你本机上包含有app的dSYM文件，其中的指令地址才能被解析成函数名（这句话是不严谨的，我们后面在解释）。

# Xcode 解析工具

解析的工作分为很多步，我们来介绍几个Xcode自带的相关小工具：

- atos，用以获取某内存地址所对应的函数名。用法：
{% highlight bash %}
$ atos -o /path/to/XXX.app/XXX.app.dSYM/Contents/Resources/DWARF/XXX -arch i386 0x973000
{% endhighlight %}
这个函数是指定了arch的，即i386，这是模拟器（或者说mac）的处理器arch，对于iOS设备就是armv6／7。如果你指定的arch和app以及dsym文件的arch不对，是会报错的。那么如何知道一个app的arch呢？前面我已经说了最常见的两个，如果你不确定是哪个，就可以用

- dwarfdump
{% highlight bash %}
$ dwarfdump -u ~/Library/Developer/Xcode/iOS\ DeviceSupport/5.0.1\ \(9A405\)/Symbols/System/Library/Frameworks/UIKit.framework/UIKit
{% endhighlight %}

- symbolicatecrash 这是symbolicate过程的核心脚本
{% highlight bash %}
$ /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKit.framework/Versions/A/Resources/symbolicatecrash 
{% endhighlight %}

# 动态库与静态库

在学习C语言的时候，我们就应该接触过这两种库，静态库是在编译时把其中涉及到的指令一起放入最终生成的app，动态库则是在运行时动态查找库的。在iOS开发中，动态库的常见形式是dylib或者Framework。

无论是app还是Framework，在生成的时候都是有特定的arch的，这是可以用dwarfdump命令可以查到。而动态库和静态库不同的是，底层动态库的内存地址在同样arch的不同app中的地址是不变的。第三方静态库和动态库的符号表在创建过程中创建dSYM文件的，而是在app编译时被放到app的dSYM文件中的。

这就是我现在不能理解的问题，如果第三方的库文件内部有错误，是可以把错误函数栈通过app的调用被暴露出来的（即使没有对应的静态库符号表）。我一直在想这是不是一种不安全的设计？

# dSYM文件生成过程

首先在build一个target为dylib、static lib、Framework的第三方项目时候都不会生成dSYM文件，只有在生成app时才会有dSYM文件，并且其中包含了不止是app中函数的符号表，同时也有其中调用的第三方库的。可以认为dSYM文件就是为了我们进行解析时使用的。但是，要注意，因为一个app和dSYM文件都是有arch的，那么同一个项目生成的arch为armv7的dSYM文件是不能供x86_64的app解析的。

# 现有Crash Log服务 
